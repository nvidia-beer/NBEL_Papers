# 2024: Continuous Adaptive Nonlinear Model Predictive Control Using Spiking Neural Networks and Real-Time Learning

## Paper Info

**Authors:** Halaly & Tsur  
**Publication:** Neuromorphic Computing and Engineering (IOPScience), 2024  
**Links:** [PDF](https://static1.squarespace.com/static/555995e2e4b0c9f3319aaa47/t/68db9726fea4af54c4a03285/1759221542713/2024+Halaly+et+al.pdf) | [IOPScience](https://iopscience.iop.org/article/10.1088/2634-4386/ad4209) | [GitHub](https://github.com/rhalaly/Adaptive-MPC-With-SNN)

---

## Overview

This paper tackles a fundamental problem with Model Predictive Control (MPC): it fails when your model doesn't perfectly match reality. The solution? Use SNNs with online learning to continuously correct model errors in real-time.

Application: Autonomous vehicle control in CARLA simulator, tested on 7 different vehicles.

<img src="../figures/2024/Environment.png" alt="CARLA Environment" width="600">

<img src="../figures/2024/Model-Schema.png" alt="Architecture" width="600">

### The Problem

**Why MPC fails:** MPC predicts future states using a model $\hat{f}(\cdot)$, but reality is $f(\cdot) + w(t)$ (disturbances). When model mismatch $\Delta f = f - \hat{f}$ is large, predictions diverge exponentially over the horizon.

**Real-world causes:**
- Actuator wear/degradation
- Environmental disturbances (wind, road friction)
- Sensor drift
- Unmodeled dynamics (tire slip, suspension)
- Parameter uncertainty (mass changes)

**Consequences:**
- Poor trajectory tracking
- Constraint violations (unsafe!)
- Suboptimal control

### The Solution

Use a hybrid predictor: classical bicycle model + adaptive SNN

$$
\hat{f}_{\text{adaptive}} = f_{\text{bicycle}} + f_{\text{SNN}}
$$

where $f_{\text{SNN}}$ learns to correct model errors using PES learning.

### Key Math

**State & Control:**

State: $\mathbf{s}_t = [x, y, \cos\theta, \sin\theta, v^x, v^y, a^x, a^y, v^r]^T$ (9D)  
Control: $\mathbf{u}_t = [\phi, \delta]^T$ (throttle, steering)

**Dynamic Error:**

The SNN minimizes error in dynamics (not just position):

$$
\mathbf{e}_{\text{dynamic}} = \dot{\mathbf{s}}_{\text{predicted}} - \dot{\mathbf{s}}_{\text{real}}
$$

This is 8D because heading $[\cos\theta, \sin\theta]$ (2D) → $\dot{\theta}$ (1D).

**Bicycle Model:**

Heading: $\theta = \tan^{-1}(\sin\theta / \cos\theta)$  
Speed: $v = \sqrt{(v^x)^2 + (v^y)^2}$  
Slip angle: $\beta = \arctan(L_r \tan\delta / L)$

$$
\begin{aligned}
\dot{x} &= v \cos(\theta + \beta) \\
\dot{y} &= v \sin(\theta + \beta) \\
\dot{\theta} &= \frac{v \tan\delta \cos\beta}{L}
\end{aligned}
$$

**PES Learning:**

$$
\Delta \mathbf{W} = -\kappa \mathbf{e}_{\text{dynamic}} \mathbf{a}^T
$$

where $\mathbf{W}$ are decoder weights, $\kappa = 10^{-4}$ is learning rate, $\mathbf{a}$ is neural activity.

**MPC Formulation:**

Standard MPC optimization:

$$
\min_{\{u(t), ..., u(t+N-1)\}} \sum_{k=0}^{N} \ell(x(t+k), u(t+k))
$$

subject to: $x(t+k+1) = f(x(t+k), u(t+k))$

The key difference: our $f$ is the adaptive predictor that continuously improves via PES learning.

**Cost Function:**

$$
J = \sum_{k=0}^{N-1} \left( \text{CTE}_k^2 + \psi_{\text{err},k}^2 + (v_k - v_{\text{ref}})^2 + \delta_k^2 + a_k^2 + \Delta\delta_k^2 + \Delta a_k^2 \right)
$$

Penalizes: cross-track error, heading error, speed error, control effort, control smoothness.

### Experiments

**Platform:** CARLA 0.9.14 simulator  
**Maps:** Town04 (highway), Town06 (urban with sharp turns)

**Vehicles tested (7 total):**

| Vehicle | Wheelbase (m) |
|---------|---------------|
| Tesla Model 3 | 2.875 |
| Ford Ambulance | 4.55 |
| Mini Cooper S | 2.467 |
| Tesla Cybertruck | 3.807 |
| Mitsubishi Fuso Rosa | 3.995 |
| Ford Mustang | 2.7432 |
| VW T2 (2021) | 2.4 |

**Test conditions:**
1. **Baseline:** Normal driving
2. **Malfunction:** 25% steering bias (simulates actuator failure)
3. **Swift Steering:** Direction changes every 10s

### Results

**Dynamic Error Reduction:**
- 5 neurons: 89.15% reduction
- 100 neurons: 93.5%
- 1000 neurons: 95.2%
- 5000 neurons: 96.08%

**Cross-Track Error (CTE):**
- Non-adaptive: ~0.8m average
- Adaptive (5 neurons): ~0.1m
- Adaptive (5000 neurons): ~0.03m

**Convergence:** 80% correction in 3-5s, 95% in 10-15s

<img src="../figures/2024/Normal-CTE.png" alt="CTE Comparison" width="600">

<img src="../figures/2024/Normal-DynamicsError-Full.png" alt="Scalability" width="600">

<img src="../figures/2024/Steermal-DynamicsError-Full.png" alt="Fault Tolerance" width="600">

### Why This Matters

**Paradigm shift:** From "MPC needs a perfect model" to "MPC learns and adapts."

**Key advantages:**
- **No offline training:** Zero pre-training, learns during operation
- **Extreme efficiency:** Even 5 neurons achieve 89% error reduction
- **Fault tolerance:** Handles 25% actuator bias seamlessly
- **Fast adaptation:** Converges in 10-15 seconds vs. months of system identification

**Practical impact:**
- Eliminates system ID bottleneck (months → seconds)
- Safety-critical applications (handles severe faults)
- Works on neuromorphic hardware (low power)
- Generalizable (any dynamical system, not just vehicles)

### Implementation

**Stack:**
- Simulator: CARLA 0.9.14
- Framework: Nengo 3.2.0 (NEF)
- Learning: PES rule
- Optimization: SciPy MPC

**Hyperparameters:**
- Timestep: 0.1s (10 Hz)
- Horizon: 5 steps (0.5s lookahead)
- Synaptic τ: 50ms
- Learning rate: $10^{-4}$
- Neurons: 5-5000 (scalable)

### Connection to Other Work

**Timeline:** 2021 (NEF/SNN foundation) → 2022 (online adaptation) → **2024 (adaptive MPC)**

**Builds on:**
- 2021: NEF infrastructure, Loihi deployment, PES learning
- 2022: Real-time model error correction

**Unique contribution:** Model-correcting MPC that doesn't need perfect system models—learns corrections continuously during operation.

**Bottom line:** 96% error reduction with 5000 neurons (89% with just 5!), zero offline training, handles severe faults. This is the first controller that truly adapts to model mismatch in real-time.

---
